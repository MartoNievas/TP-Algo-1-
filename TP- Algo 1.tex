\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\input{AEDmacros}
\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex


\titulo{Trabajo Practico de Especificacion}
\subtitulo{Especificacion y WP(Weakness Precondition)}

\fecha{\today}

\materia{Algoritmos y Estructuras de Datos 1}
\grupo{pesutipolimardiano}

\integrante{Nievas, Martin}{453/24}{tinnivas@gmail.com}
\integrante{Bercovich, Maximo}{002/01}{email2@dominio.com}
\integrante{Apellido, Nicolas}{003/01}{email3@dominio.com}
\integrante{Pomsztein, Andy}{624/24}{pomszteinandy@gmai.com}
\graphicspath{{../static/}}

\begin{document}

\maketitle
\section {Enunciados}
\subsection{Especficiacion}

\begin{quote}
\vspace{0.2cm}
\textbf{1. grandesCiudades} A partir de una lista de ciudades, devuelve aquellas que tienen m´as de 50.000 habitantes.
\textbf {proc  grandesCiudades} (\In ciudades: \TLista{Ciudad}) : \TLista{Ciudad}
\vspace{0.2cm}
\\
\vspace{0.2cm}
\textbf{2. sumaDeHabitantes:} Por cuestiones de planificacion urbana, las ciudades registran sus habitantes mayores de edad
por un lado y menores de edad por el otro. Dadas dos listas de ciudades del mismo largo con los mismos nombres, una
con sus habitantes mayores y otra con sus habitantes menores, este procedimiento debe devolver una lista de ciudades
con la cantidad total de sus habitantes.
\\
\vspace{0.2cm}
\textbf {proc sumaDeHabitantes} (\In menoresDeCiudades: \TLista{Ciudad}, \In mayoresDeCiudades: \TLista{Ciudad}) : \TLista{Ciudad}
\\
\vspace{0.2cm}
\textbf{3. hayCamino:} Un mapa de ciudades esta conformada por ciudades y caminos que unen a algunas de ellas. A partir de
este mapa, podemos definir las distancias entre ciudades como una matriz donde cada celda i, j representa la distancia
entre la ciudad i y la ciudad j (Fig. 2). Una distancia de 0 equivale a no haber camino entre i y j. Notar que la distancia
de una ciudad hacia s´ı misma es cero y la distancia entre A y B es la misma que entre B y A.
\vspace{0.2cm}
\\ 
\vspace{0.2cm}
\textbf{proc hayCamino} o (\In distancias: \matriz{\ent}, \In desde: \ent, \In hasta: \ent) : \bool
\vspace{0.2cm}
\\
\vspace{0.2cm}
\textbf{4. cantidadCaminosNSaltos:} Dentro del contexto de redes informaticas, nos interesa contar la cantidad de “saltos”
que realizan los paquetes de datos, donde un salto se define como pasar por un nodo.
Ası como definimos la matriz de distancias, podemos definir la matriz de conexion entre nodos, donde cada celda i, j
tiene un 1 si hay un unico camino a un salto de distancia entre el nodo i y el nodo j, y un 0 en caso contrario. En este
caso, se trata de una matriz de conexion de orden 1, ya que indica cu´ales pares de nodos poseen 1 camino entre ellos a
1 salto de distancia.
Dada la matriz de conexion de orden 1, este procedimineto debe obtener aquella de orden n que indica cuantos caminos
de n saltos hay entre los distintos nodos. Notar que la multiplicacion de una matriz de conexion de orden 1 consigo
misma nos da la matriz de conexion de orden 2, y ası sucesivamente.4
\\
\vspace{0.2cm}
\textbf{proc cantidadNSaltos } s (\Inout conexion: \matriz{\ent}, \In n: \ent)
\vspace{0.2cm}
\\
\vspace{0.2cm}
\textbf{5. caminoMınimo:} caminoMınimo: Dada una matriz de distancias, una ciudad de origen y una ciudad de destino, este procedimiento
debe devolver la lista de ciudades que conforman el camino mas corto entre ambas. En caso de no existir un camino,
se debe devolver una lista vacıa.
\\
\textbf{proc caminoMinimo} (in origen: \ent, in destino: \ent, in distancias: seq⟨seq⟨\ent⟩⟩) : seq⟨\ent⟩
\end {quote}
\subsection{WP (Weakest Precondiction)}
\begin{quote}
	La funcion poblacionTotal recibe una lista de ciudades donde al menos una de ellas es grande (es decir, supera los
	50.000 habitantes) y devuelve la cantidad total de habitantes. Dada la siguiente especificacion:
	\begin{proc}{poblacionTotal}{\In ciudades : \TLista{Ciudad}}{\ent}
		\requiere {\existe[unalinea]{i}{\ent}{0 \leq i < \longitud{ciudades} \yLuego ciudades[i].habitantes > 50,000 \land \paraTodo[unalinea]{i}{\ent}{0 \leq i < \longitud{ciudades} \implicaLuego ciudades[i].habitantes \geq 0 } \land \paraTodo[unalinea]{i, j}{\ent}{0 \leq i < j \implicaLuego ciudades[i].nombre \neq ciudades[j].nombre }}}		
		\asegura{res = \sum_{i=0}^{\longitud{ciudades}-1}ciudades[i].habitantes}
	\end{proc}
	\text{Con la siguiente implementacion:}
	\begin{lstlisting}[caption={},label=code:for]
		res := 0;
		i := 0;
		while (i < ciudades.lenght()) do
		res := res + ciudades[i].habitantes;
		i := i + 1
		endwhile
	\end{lstlisting}
	\begin{itemize}
		\item1. Demostrar que la implementacion es correcta con respecto a la especificacion.
		\item2. Demostrar que el valor devuelto es mayor a 50.000.
	\end{itemize}
\end{quote}
\section{Predicados Reutilizables}
\begin{quote}
	\pred{todosPositivos}{ s : \TLista{\ent}}{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |s| \implicaLuego s[i] \geq 0}}
	\vspace{0.2cm}
	\pred{distanciasValidas}{distancias : \matriz{\ent}}{\paraTodo[unalinea]{i}{\ent}{0 \leq i < \longitud{distancias} \implicaLuego todosPositivos(distancias[i])}}
	\vspace*{0.2cm}
	\pred{diagonalEnCeros}{ s : \matriz{\ent}}{\paraTodo[unalinea]{i, j}{\ent}{0 \leq i < |s| \land 0 \leq j < s[i] \land i = j \implicaLuego s[i][j] = 0}}
	\vspace{0.2cm}
	\pred{esMatrizSimetrica}{ s : \matriz{\ent}}{\paraTodo[unalinea]{i, j}{\ent}{0 \leq i < |s| \land 0 \leq j < |s[i]| \implicaLuego s[i][j] = s[j][i]}}
	\vspace{0.2cm}
	\pred{esMatrizCuadrada}{ s : \matriz{\ent}}{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |s| \implicaLuego |s[i]| = |s|}}
	\vspace*{0.2cm}
	\pred{esCamino}{ distancias : \matriz{\ent}, c : \TLista{\ent}, d : \ent, h : \ent}{(esMatrizCuadrada(distancias) \land |c| \geq 2) \yLuego (|c| \geq 1)  \paraTodo[unalinea]{e}{\ent}{e \in c \implicaLuego 0 \leq c < |distancias| \land (c[0] = d \land c[|c|-1] = h) \land \paraTodo[unalinea]{i}{\ent}{ 0 \leq i < |c|-1 \implicaLuego distancias[c[i]][c[i+1]] > 0 }}}
\end{quote}
\section{Resolucion de Ejercicios}
\subsection{Especificacion}
\begin{quote}
	\textbf{Ejercicio 1:}
	\vspace{0.2cm}
	\begin{proc}{grandesCiudades}{\In ciudades : \TLista{Ciudad}}{\TLista{Ciudad}}
		\requiere{\True}
		\asegura{|res| = cantidadCiudadesGrandes(ciudades)  \land sonTodasCiudadesGrandes(res) \land \paraTodo[unalinea]{c}{Ciudad}{c \in res \implicaLuego c \in ciudades}}
	\end{proc}	
	\pred{sonTodasCiudadesGrandes}{ ciudades : \TLista{Ciudad}}{
		(\paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades| \implicaLuego ciudades[i].habitantes > 50000})   
	}
	\vspace{0.2cm}
	\aux{cantidadCiudadesGrandes}{ ciudades :\TLista{Ciudad}}{\ent}{\sum_{i = 0}^{|s|-1}{( \IfThenElse{s[i].habitantes > 50000}{1}{0})}
	}
	\vspace*{0.2cm}
	\textbf{Ejercicio 2:}
	\begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades : \TLista{Ciudad}, \In mayoresDeCiudad : \TLista{Ciudad}}{\TLista{Ciudad}}
		\requiere{|menoresDeCiudades| = |mayoresDeCiudades|  \land \\ mismasCiudades(menoresDeCiudades, mayoresDeCiudades \land \\ ciudadesDistintas(menoresDeCiudades) \land ciudadesDistintas(mayoresDeCiudades))}
		\asegura{\longitud{res} = \longitud{menoresDeCiudades} \land esLaSuma(res, menoresDeCiudades, mayoresDeCiudades) \land \\ mismasCiudades(res, menoresDeCiudades) \land mismasCiudades(res, mayoresDeCiudades) }
	\end{proc}
	\pred{mismasCiudades}{ s: \TLista{Ciudad},  l: \TLista{Ciudad}}{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |s| \implicaLuego \existe[unalinea]{j}{\ent}{0 \leq j < |l| \yLuego s[i].nombre = l[j].nombre}} }
	\vspace{0.2cm}
	\pred{esLaSuma}{ res : \TLista{Ciudad},  s: \TLista{Ciudad},  l: \TLista{Ciudad}}{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |res| \implicaLuego \existe[unalinea]{j,k}{\ent}{0 \leq j < |s| \land 0 \leq k < |l| \yLuego s[j].nombre = l[k].nombre \land res[i].habitantes = s[j].habitantes + l[k].habitantes }}}
	\vspace{0.2cm}
	\pred{ciudadesDistintas}{ ciudades : \TLista{Ciudad}}{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades| \implicaLuego \neg \existe[unalinea]{j}{\ent}{0 \leq j <|ciudades| \land i \neq j \yLuego ciudades[i].nombre = ciudades[j].nombre} }}
	\vspace*{0.2cm}
	\textbf{Ejercicio 3:}
	\begin{proc}{hayCamino}{\In distancias : \matriz{\ent}, \In desde : \ent, \In hasta : \ent}{\bool}
		\requiere{esMatrizCuadrada(distancias) \land diagonalEnCeros(distancias) \land esMatrizSimetrica(distancias) \land distanciasValidas(distancias) \land ( 0 \leq desde < |distancias| \land 0 \leq hasta < |distancias|)}
		\asegura{res = \True \longleftrightarrow \existe[unalinea]{c}{\TLista{\ent}}{esCamino (distancias, c, desde, hasta) \vee (distacias[desde][hasta] > 0)}}
	\end{proc}
	\textbf{Ejercicio 4:} \\
	\begin{proc}{cantidadDeCaminosNSaltos}{\Inout conexion : \matriz{\ent}, n : \ent}{}
		\requiere{conexion = conexion_0 \land esMatrizCuadrada(conexion) \land cerosEnLaDiagonal(conexion) \land esMatrizSimetrica(conexion) \land esMatrizConCerosYUnos(conexion) }	
		\asegura{\longitud{conexion} = \longitud{conexion_0} \yLuego \paraTodo[unalinea]{i}{\ent}{0 \leq i < \longitud{conexion_0} \implicaLuego \longitud{conexion[i]} = \longitud{conexion_0} \land esMatrizDeOrdenN(conexion,conexion_0,n)}}
	\end{proc}
	\vspace{0.2cm}
	\pred{esMatrizConCerosYUnos}{conexion : \matriz{\ent}}{\paraTodo[unalinea]{i, j}{\ent}{0 \leq 0 < \longitud{conexion} \land i \leq j < \longitud{conexion[i]} \implicaLuego (conexion[i][j] = 0 \vee conexion[i][j] = 1)}}
	\vspace*{0.2cm}
	\pred{esIdentidad}{m : \matriz{\ent}}{esMatrizCuadra \yLuego \paraTodo[unalinea]{i, j}{\ent}{0 \leq i < \longitud{m} \land 0 \leq j < \longitud{m[i]} \implicaLuego ((i = j \land m[i][j] = 1) \vee (i \neq j \land m[i][j] = 0))}}
	\vspace*{0.2cm}
	\pred{esProducto}{m : \matriz{\ent}, n : \matriz{\ent}, o : \matriz{\ent}, n : \ent}{\paraTodo[unalinea]{i, j}{\ent}{0 \leq i < \longitud{m} \land 0 \leq j < \longitud{m[i]} \implicaLuego m[i][j] = \sum_{k = 0}^{\longitud{n} -1} n[i][k] * o[k][j]}}
	\vspace*{0.2cm}
	\pred{esMatrizDeOrdenN}{s : \matriz{\ent}, l : \matriz{\ent}}{\existe[unalinea]{lista}{\TLista{\matriz{\ent}}}{(\longitud{lista} = n + 1 \land esIdentidad(lista[0]) \land lista[1] = l \land lista[n] = s ) \land \paraTodo[unalinea]{i}{\ent}{1 \leq i \leq n \implicaLuego (esProducto(lista[i],lista[i-1],lista[1]))}}}
	\textbf{Ejericio 5:} \\
	\begin{proc}{caminoMinimo}{\In origen : \ent, \In destino : \ent, \In distancias : \matriz{\ent}}{\TLista{\ent}}
		\requiere{(diagonalEnCeros(distancias) \land esMatrizCuadrada(distancias) \land esMatrizSimetrica(distancias) \land distanciasValidas(distancias) \land (0 \leq origen < \longitud{distancias} \land 0 \leq destino < \longitud{distancias}))}
		\asegura{(esCamino(res) \yLuego \paraTodo[unalinea]{c}{\TLista{\ent}}{esCamino(c) \implicaLuego distanciaRecorrida(distancias, res) \geq distanciaRecorrida(distancias, c)}) \vee (res = \lvacia) \longleftrightarrow \neg \existe[unalinea]{c}{\TLista{\ent}}{esCamino(distancias, c, origen, destino)}}
	\end{proc}
	\aux{distanciaRecorrida}{distancias : \matriz{\ent}, c : \TLista{\ent}}{\ent}{\sum_{i = 0}^{\longitud{c}-2}distancias[c[i]][c[i+1]]}
\end{quote}
\subsection{WP (Weakest Precondition)}
\begin{quote}
 \textbf{Primer item:} 
 \\
 Para demostrar la correctitud de la implementación del programa con respecto a su especificación, debemos ver los siguientes puntos:
 \begin{quote}
 \begin{itemize}
 	\item \textbf{P \implica $P_c$:} (La precondición de la especificación implica la precondición del ciclo.)
 	\item \textbf{Correctitud parcial del ciclo} 
 	\item \textbf{Terminación del Ciclo} 
 \end{itemize}
 \end{quote}
 

 
\end{quote}
\end{document}
