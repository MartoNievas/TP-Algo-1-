\documentclass[10pt,a4paper]{article}

\input{AEDmacros}
\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex


\titulo{Trabajo Practico de Especificacion}
\subtitulo{Especificacion y WP(Weakness Precondition)}

\fecha{\today}

\materia{Algoritmos y Estructuras de Datos 1}
\grupo{pesutipolimardiano}

\integrante{Nievas, Martin}{453/24}{tinnivas@gmail.com}
\integrante{Bercovich, Maximo}{002/01}{email2@dominio.com}
\integrante{Apellido, Nicolas}{003/01}{email3@dominio.com}
\integrante{Pomsztein, Andy}{624/24}{pomszteinandy@gmai.com}
\graphicspath{{../static/}}

\begin{document}

\maketitle
\section {Enunciados}
\subsection{Especficiacion}

\begin{quote}
\vspace{0.2cm}
\textbf{1. grandesCiudades} A partir de una lista de ciudades, devuelve aquellas que tienen m´as de 50.000 habitantes.
\textbf {proc  grandesCiudades} (in ciudades: seq⟨Ciudad⟩) : seq⟨Ciudad⟩
\vspace{0.2cm}
\\
\vspace{0.2cm}
\textbf{2. sumaDeHabitantes:} Por cuestiones de planificacion urbana, las ciudades registran sus habitantes mayores de edad
por un lado y menores de edad por el otro. Dadas dos listas de ciudades del mismo largo con los mismos nombres, una
con sus habitantes mayores y otra con sus habitantes menores, este procedimiento debe devolver una lista de ciudades
con la cantidad total de sus habitantes.
\\
\vspace{0.2cm}
\textbf {proc sumaDeHabitantes} (in menoresDeCiudades: seq⟨Ciudad⟩, in mayoresDeCiudades: seq⟨Ciudad⟩) : seq⟨Ciudad⟩
\\
\vspace{0.2cm}
\textbf{3. hayCamino:} Un mapa de ciudades esta conformada por ciudades y caminos que unen a algunas de ellas. A partir de
este mapa, podemos definir las distancias entre ciudades como una matriz donde cada celda i, j representa la distancia
entre la ciudad i y la ciudad j (Fig. 2). Una distancia de 0 equivale a no haber camino entre i y j. Notar que la distancia
de una ciudad hacia s´ı misma es cero y la distancia entre A y B es la misma que entre B y A.
\vspace{0.2cm}
\\ 
\vspace{0.2cm}
\textbf{proc hayCamino} o (in distancias: seq⟨seq⟨\ent⟩⟩, in desde: \ent, in hasta: \ent) : \bool
\vspace{0.2cm}
\\
\vspace{0.2cm}
\textbf{4. cantidadCaminosNSaltos:} Dentro del contexto de redes informaticas, nos interesa contar la cantidad de “saltos”
que realizan los paquetes de datos, donde un salto se define como pasar por un nodo.
Ası como definimos la matriz de distancias, podemos definir la matriz de conexion entre nodos, donde cada celda i, j
tiene un 1 si hay un unico camino a un salto de distancia entre el nodo i y el nodo j, y un 0 en caso contrario. En este
caso, se trata de una matriz de conexion de orden 1, ya que indica cu´ales pares de nodos poseen 1 camino entre ellos a
1 salto de distancia.
Dada la matriz de conexion de orden 1, este procedimineto debe obtener aquella de orden n que indica cuantos caminos
de n saltos hay entre los distintos nodos. Notar que la multiplicacion de una matriz de conexi´on de orden 1 consigo
misma nos da la matriz de conexion de orden 2, y ası sucesivamente.4
\\
\vspace{0.2cm}
\textbf{proc cantidadNSaltos } s (inout conexi´on: seq⟨seq⟨\ent⟩⟩, in n: \ent)
\vspace{0.2cm}
\\
\vspace{0.2cm}
\textbf{5. caminoMınimo:} caminoMınimo: Dada una matriz de distancias, una ciudad de origen y una ciudad de destino, este procedimiento
debe devolver la lista de ciudades que conforman el camino mas corto entre ambas. En caso de no existir un camino,
se debe devolver una lista vacıa.
\\
\textbf{proc caminoMinimo} (in origen: \ent, in destino: \ent, in distancias: seq⟨seq⟨\ent⟩⟩) : seq⟨\ent⟩
\end {quote}
\subsection{WP (Weakest Precondiction)}

\section{Resolucion de Ejercicios}

\begin{quote}
	\textbf{Ejercicio 1:}
	\vspace{0.2cm}
	\\
	\vspace*{0.2cm}
	\pred{sonTodasCiudadesGrandes}{\In ciudades: seq⟨Ciudad⟩}{
		(\paraTodo[unalinea]{i}{\ent}{0 \leq i < |ciudades| \implicaLuego ciudades[i].habitantes > 50000})   
	}
	\vspace{0.2cm}
	\aux{cantidadCiudadesGrandes}{\In ciudades : seq⟨Ciudad}{\ent}{\sum_{i = 0}^{|s|-1}{( \IfThenElse{s[i].habitantes > 50000}{1}{0})}
	}
	\vspace*{0.2cm}
	\begin{proc}{grandesCiudades}{\In ciudades : \TLista{Ciudad}}{\TLista{Ciudad}}
		\requiere{\True}
		\asegura{|res| = cantidadCiudadesGrandes(ciudades)  \land sonTodasCiudadesGrandes(ciudades) \land \paraTodo[unalinea]{c}{Ciudad}{c \in res \implicaLuego c \in ciudades}}
	\end{proc}	
	\textbf{Ejercicio 2:}
	\vspace{0.2cm}
	\\ 
	\pred{mimasCiudades}{\In s: \TLista{Ciudad}, \In l: \TLista{Ciudad}}{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |s| \implicaLuego \existe[unalinea]{j}{\ent}{0 \leq j < |l| \yLuego s[i].nombre = l[j].nombre}} }
	\vspace{0.2cm}
	\pred{esLaSuma}{\In res : \TLista{Ciudad}, \In s: \TLista{Ciudad}, \In l: \TLista{Ciudad}}{\paraTodo[unalinea]{i}{\ent}{0 \leq i < |res| \implicaLuego \existe[unalinea]{j,k}{\ent}{0 \leq j < |s| \land 0 \leq k < |l| \yLuego res[i].habitantes = s[j].habitantes + l[k].habitantes }}}
	\vspace{0.2cm}
	\begin{proc}{sumaDeHabitantes}{\In menoresDeCiudades : \TLista{Ciudad}, \In mayoresDeCiudad : \TLista{Ciudad}}{\TLista{Ciudad}}
		\requiere{|menoresDeCiudades| = |mayoresDeCiudades|  \land \\ mismasCiudades(menoresDeCiudades, mayoresDeCiudades)}
		\asegura{esLaSuma(res, menoresDeCiudades, mayoresDeCiudades) \land \\ mismasCiudades(res, menoresDeCiudades) \land mismasCiudades(res, mayoresDeCiudades)}
	\end{proc}
	\textbf{Ejercicio 3:}
	
\end{quote}





\end{document}
